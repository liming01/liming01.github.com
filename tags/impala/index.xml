<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Impala on 沙漠守望者</title>
    <link>https://liming01.github.io/tags/impala/</link>
    <description>Recent content in Impala on 沙漠守望者</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2017 Ming LI</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 11:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/impala/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>强者更强：HAWQ性能的思考</title>
      <link>https://liming01.github.io/post/hawq-feature/</link>
      <pubDate>Wed, 20 Apr 2016 11:00:00 +0000</pubDate>
      
      <guid>https://liming01.github.io/post/hawq-feature/</guid>
      <description>

&lt;p&gt;&lt;div align = right&gt; ------ 作者：李明(email: mli@apache.org) &lt;/div&gt; &lt;/p&gt;

&lt;p&gt;SQL on Hadoop产品非常繁多，从性能角度来看，比较好的有HAWQ、Impala。虽然目前HAWQ还是大幅领先于Impala（参见：&lt;a href=&#34;https://blog.pivotal.io/big-data-pivotal/products/performance-benchmark-pivotal-hawq-beats-impala-apache-hive-part-1&#34; target=&#34;_blank&#34;&gt;pivotal公布的hawq性能测试&lt;/a&gt;)，但是从最近的Impala的&lt;a href=&#34;https://www.cloudera.com/documentation/enterprise/release-notes/topics/impala_new_features.html#new_features_250&#34; target=&#34;_blank&#34;&gt;新版本发布公告&lt;/a&gt;来看，它最近一直集中精力实现各种新的优化手段。为了使HAWQ继续保持竞争力，我们有必要学习其他竞争对手的优点，才能做到“知彼知己者，百战不殆”。&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;本文的观点仅代表本人观点，用于学习探讨交流。若因此出现经济、法律等方面的，与本人无关。&lt;/p&gt;

&lt;/div&gt;


&lt;h2 id=&#34;hawq-to-do-list&#34;&gt;HAWQ TO DO LIST&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Data skipping for I/O bound query:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;parquet/orc index( min/max/bloom filter) usage&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Runtime filter&lt;/li&gt;
&lt;li&gt;Dynamic partition pruning
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Intra-Operator parallel processing vs vSeg number:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IO intensive operator: base table scan: thread number = disk rotationar number&lt;/li&gt;
&lt;li&gt;CPU intensive operator: joins/aggregations/sort/top-N, thread number = cpu core number
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LLVM Codegen for CPU bound query:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function call unrolling and branch pruning: Expression/loop/no switching&lt;/li&gt;
&lt;li&gt;CPU intensive operator: joins/aggregations/sort/top-N&lt;/li&gt;
&lt;li&gt;more hotspots: counting the elements of a complex column, Checking for overflow in DECIMAL multiplication, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use HDFS caching feature to &amp;ldquo;pin&amp;rdquo; entire tables or individual partitions in memory, to speed up queries on frequently accessed data and reduce the CPU overhead of memory-to-memory copying.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Duplicate small table to all segments to speed up join with other distributed tables.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;streaming pre-aggregation: decides at run time whether it is more efficient to do an initial aggregation phase and pass along a smaller set of intermediate data, or to pass raw intermediate data back to next phase of query processing to be aggregated there.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Optimization for small queries let Impala process queries that process very few rows without the unnecessary overhead of parallelizing and generating native code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;more parallel processing: SIMD, vectorization&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Distributed by hash is one kind of partition?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;better info for different level: explain/SUMMARY/profile&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
